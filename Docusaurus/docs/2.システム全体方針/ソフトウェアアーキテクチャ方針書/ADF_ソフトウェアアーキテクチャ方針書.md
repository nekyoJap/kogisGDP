あなたはDDDおよびクリーンアーキテクチャを理解したシステムアーキテクトです。\
以下の【形式】および【ISO/IEC Directives Part 2準拠ルール】に基づいて、対象システムの「ソフトウェアアーキテクチャ方針書」を作成してください。\
出力はすべてMarkdown形式で記載してください（JSON形式・CSV形式は禁止）。\
また、成果物（表・文章）の提示より先に、必ず抽出・推論過程をstep-by-stepで記載し、\
その後に章立てに沿って成果物を順序厳守で出力してください。\
推測による情報補完は禁止し、不明点は必ず「未確定」と明記してください。

---

### 【形式】

章：`## 第1章 タイトル`\
節：`### 1.1 タイトル`\
項：`#### 1.1.1 タイトル`\
その他：通常テキスト\
表はMarkdown表形式で記載し、表番号とキャプションを付与する（例：`**表1 — 〇〇一覧**`）\
JSON / CSV形式は禁止

---

### 【ISO/IEC Directives Part 2準拠ルール】

#### 要求事項の表現
出力文書では以下の表現を使い分けること：

| 表現 | 用途 | 英語対応 |
|------|------|----------|
| 〜しなければならない | 要求事項 | shall |
| 〜してはならない | 禁止事項 | shall not |
| 〜することが望ましい | 推奨事項 | should |
| 〜しないほうがよい | 非推奨 | should not |
| 〜してもよい | 許可事項 | may |
| 〜できる | 可能性・能力 | can |

#### 文書構成の原則
- 要求事項と説明・解説を明確に区別すること
- 各章・節には目的を明示すること
- 表には連番とキャプションを付与すること

---

## 第1章 適用範囲

### 1.1 目的

本書は、ハウスクレジット基幹システムにおけるソフトウェアアーキテクチャの共通方針を定め、\
DDD（ドメイン駆動設計）およびクリーンアーキテクチャに基づく設計・実装の一貫性を確保することを目的とする。\
本書で定義されたアーキテクチャ方針に反する設計・実装を行ってはならない。

### 1.2 適用範囲

**表1 — 適用範囲**
| 項目 | 記述内容 |
|----|------|
| 対象システム | ハウスクレジット基幹システム |
| 対象BC | ドメインスコープ定義書およびコンテキストマップに定義された全BC |
| 除外対象 | 未確定（PoC／一時検証用コンポーネントは例外承認対象とする想定だが詳細運用ルールは未確定） |

### 1.3 関連文書

本書は「システム全体方針検討」に属するアーキテクチャ指針であり、以下のドキュメントと連携する。

**表2 — 関連文書一覧**
| 関連ドキュメント | 関係性 |
|----------------|--------|
| ドメインスコープ定義書 | BC構造・境界の定義をインプットとする |
| コンテキストマップ | BC間関係の定義をインプットとする |
| データモデリング方針書 | 永続化層の設計方針と整合する |
| APIガバナンス方針書 | API設計方針と整合する |
| 非同期連携方針書 | BC間連携の詳細を参照する |
| テスト・品質保証方針書 | SBE/TDDの詳細を参照する |

BC間連携の詳細方針は別ドキュメント（非同期連携方針書、APIガバナンス方針書等）で定義し、\
本書ではDDD・クリーンアーキテクチャの基本的な考え方のみを定義する。

---

## 第2章 引用規格

本書は以下の規格・標準を参照する：

- ISO/IEC 25010:2011 システム及びソフトウェア品質モデル
- IEEE 1471-2000 ソフトウェア集約システムのアーキテクチャ記述

---

## 第3章 用語及び定義

本書で使用する主要な用語を以下に定義する：

**表3 — 用語定義**
| 用語 | 定義 |
|------|------|
| BC（Bounded Context） | DDDにおける境界づけられたコンテキスト。モデルの適用範囲を明確に区切る境界 |
| 集約（Aggregate） | 整合性境界を形成するエンティティ・VOの集まり |
| ユビキタス言語 | ドメインエキスパートと開発者が共通して使用する言語 |
| クリーンアーキテクチャ | 依存関係を内側に向けることで、ドメインロジックを外部依存から保護するアーキテクチャ |
| CQRS | Command Query Responsibility Segregation（コマンドクエリ責務分離） |

---

## 第4章 入力情報と前提

### 4.1 入力アセット

以下の正式インプットを前提とする（添付資料に基づく）：

### 4.2 前提条件

* 本方針書は、「ドメインスコープ定義書」「コンテキストマップ」で定義された **BC構造・境界が確定していること** を前提とする。
* 各BCは自律性を持つマイクロサービス（想定）として設計され、**アーキテクチャはBC単位で独立して適用されること** を前提とする。
* ドメインモデルは、クリーンアーキテクチャの中心に位置し、**フレームワーク・データベース・UIに依存しない** ことを前提とする。
* 仕様の陳腐化を防ぐため、**SBE（Specification by Example）に基づくLiving Documentation** を採用することを前提とする。
* 監査ログ・アプリケーションログの参照には **CQRSパターン** の適用を検討することを前提とする。
* BC間連携の詳細方針（イベント駆動、Saga、Outbox等）は **非同期連携方針書** で定義されることを前提とする。
* API設計の詳細方針は **APIガバナンス方針書** で定義されることを前提とする。

---

## 第5章 対象BC一覧

コンテキストマップより抽出した対象BC一覧を以下に示す。

**表4 — 対象BC一覧**
| No. | ドメイン | サブドメイン | BC | BC概要 |
|----|------|--------|----|------|
| 1 | 売上管理 | 売上取込 | 売上取込BC | ブランド/ネットワークからの売上受入・重複/形式チェック。 |
| 2 | 売上管理 | 売上確定 | 売上確定BC | 審査後の売上確定・取消制御・請求連携の起点。 |
| 3 | 売上管理 | オーソリ反映 | オーソリ反映BC | オーソリ結果・解約等に伴う即時利用可否反映。詳細未確定。 |
| 4 | 会員精算管理 | 請求管理 | 請求BC | サイクル集計・請求締め・会計連携候補の生成。 |
| 5 | 会員精算管理 | 入金管理 | 入金BC | 口座振替/全銀振込の結果取込・消込・未収管理。 |
| 6 | 会員精算管理 | 返金処理 | 返金BC | 返金起案/承認/実行と結果反映。 |
| 7 | ポイント管理 | ポイント管理 | ポイントBC | 売上連携によるポイント付与/利用/失効・履歴管理。 |
| 8 | 審査発行管理 | 与信審査 | 審査BC | 申込〜eKYC/信用照会〜審査判定。 |
| 9 | 審査発行管理 | カード発行 | 発行BC | 発番・印刷・発送・受領管理。 |
| 10 | 加盟店契約管理 | 契約/審査 | 加盟店契約BC | 加盟店申請→名寄せ→登録、属性/契約変更・停止/解約。 |
| 11 | 加盟店契約管理 | 契約/審査 | 加盟店審査BC | 加盟店審査・外部信用情報機関への照会。 |
| 12 | 会計統合管理 | 日計/会計連携 | 日計管理BC | 仕訳基準・日計管理。 |
| 13 | 会計統合管理 | 日計/会計連携 | 会計連携BC | 会計連携用I/F加工（外部会計システム連携）。 |
| 14 | 共通運用管理 | 共通マスタ/日付 | 共通マスターBC | 住所・金融・コード・休日など共通マスタ。全ドメイン参照。 |
| 15 | 共通運用管理 | 共通マスタ/日付 | 運用日付BC | システム日付等の運用日付管理。 |
| 16 | 顧客管理 | 顧客 | 顧客BC | 顧客基本情報管理。詳細未確定。 |
| 17 | 顧客管理 | 連絡先・住所 | 連絡先・住所BC | 顧客の連絡先・住所情報管理。共通マスターBCとShared Kernel。 |
| 18 | 顧客管理 | 解約 | 解約BC | 解約登録・利用停止トリガ管理。 |

---

## 第6章 アーキテクチャ基本方針（DDD）

### 6.1 DDD採用の目的

本システムでは、複雑なビジネスドメインを適切にモデル化し、ソフトウェアの構造とビジネスの構造を一致させるため、\
DDD（ドメイン駆動設計）を採用する。

**表5 — DDD採用目的**
| 目的 | 説明 |
|-----|------|
| ビジネスとコードの整合 | ユビキタス言語を通じて、ドメインエキスパートと開発者の共通理解を形成する |
| 複雑性の管理 | BCによる境界の明確化で、複雑なドメインを管理可能な単位に分割する |
| 変更容易性 | ドメインモデルの独立性により、ビジネス変更に追従しやすい構造を実現する |
| 自律性の確保 | BC単位での独立した開発・デプロイを可能にする |

### 6.2 戦略的設計の原則

#### 6.2.1 境界づけられたコンテキスト（Bounded Context）

**表6 — BC設計原則**
| 原則 | 説明 |
|-----|------|
| BC単位のモデル | 各BCは独自のドメインモデルを持ち、他BCのモデルを直接参照してはならない |
| ユビキタス言語の範囲 | ユビキタス言語はBC内で一貫性を持ち、BC間では同じ用語が異なる意味を持つことを許容する |
| 自律性 | 各BCは独立してデプロイ・スケール可能な単位として設計しなければならない |

#### 6.2.2 コンテキスト間関係の基本パターン

BC間の関係は、コンテキストマップで定義されたパターンに従う。詳細は別ドキュメントで定義するが、基本パターンは以下の通り。

**表7 — コンテキスト間関係パターン**
| パターン | 説明 | 適用場面 |
|---------|------|----------|
| ACL（Anti-Corruption Layer） | 外部システムやレガシーシステムとの連携時に、翻訳層を設けて自BC のモデルを保護する | 外部会計システム、銀行口座振替API等との連携 |
| Shared Kernel | 複数BCで共有する小さなモデルを定義し、共同で管理する | 連絡先・住所BCと共通マスターBC |
| Customer/Supplier | 上流BC（Supplier）が下流BC（Customer）の要求に応じてAPIを提供する | BC間の依存関係がある場合 |
| Published Language | 標準化されたスキーマ・プロトコルでBC間を連携する | イベント駆動連携 |

### 6.3 戦術的設計の原則

#### 6.3.1 ドメインモデルの構成要素

**表8 — ドメインモデル構成要素**
| 要素 | 説明 | 設計上の注意点 |
|-----|------|---------------|
| エンティティ（Entity） | 識別子を持ち、ライフサイクルを通じて同一性が維持されるオブジェクト | 識別子による同一性判定、状態変化を許容 |
| 値オブジェクト（Value Object） | 識別子を持たず、属性の組み合わせで同一性が判定されるオブジェクト | イミュータブル、等価性による比較、副作用なし |
| 集約（Aggregate） | 整合性境界を形成するエンティティ・VOの集まり | トランザクション整合性の単位、集約ルートを通じてのみアクセス |
| ドメインサービス | エンティティ・VOに属さないドメインロジック | ステートレス、ドメイン層に配置 |
| ドメインイベント | ドメイン内で発生した重要な出来事 | 過去形で命名、イミュータブル |
| リポジトリ | 集約の永続化・取得を担う抽象 | ドメイン層にインタフェース、インフラ層に実装 |

---

## 第7章 クリーンアーキテクチャ方針

### 7.1 クリーンアーキテクチャ採用の目的

本システムでは、フレームワーク・データベース・UIに依存しないドメインモデルを実現するため、\
クリーンアーキテクチャを採用する。

**表9 — クリーンアーキテクチャ採用目的**
| 目的 | 説明 |
|-----|------|
| フレームワーク非依存 | ドメインロジックがフレームワークに依存せず、技術変更に強い構造を実現する |
| テスタビリティ | ドメインロジックを外部依存なしにテスト可能にする |
| UI非依存 | UIの変更がドメインロジックに影響を与えない |
| DB非依存 | データベースの変更がドメインロジックに影響を与えない |

### 7.2 同心円構造の定義

クリーンアーキテクチャの同心円構造を以下のように定義する。内側の層は外側の層に依存してはならない。

```
┌─────────────────────────────────────────────────────────────┐
│                  Frameworks & Drivers                       │
│  (Web Framework, DB, External Services, UI)                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Interface Adapters                      │   │
│  │  (Controllers, Presenters, Gateways, Repositories)  │   │
│  │  ┌─────────────────────────────────────────────┐    │   │
│  │  │            Application                       │    │   │
│  │  │         (Use Cases)                         │    │   │
│  │  │  ┌─────────────────────────────────────┐   │    │   │
│  │  │  │           Domain                     │   │    │   │
│  │  │  │  (Entities, Value Objects,          │   │    │   │
│  │  │  │   Domain Services, Domain Events)   │   │    │   │
│  │  │  └─────────────────────────────────────┘   │    │   │
│  │  └─────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 7.3 各層の責務と配置要素

**表10 — 各層の責務と配置要素**
| 層 | 責務 | 配置要素 |
|----|------|----------|
| Domain | ビジネスルール・ドメインロジックの表現 | Entity, Value Object, Domain Service, Domain Event, Repository Interface |
| Application | ユースケースの実現、アプリケーション固有のビジネスルール | Use Case (Interactor), Input Port, Output Port, Application Service |
| Interface Adapters | 外部との入出力の変換 | Controller, Presenter, Gateway Implementation, Repository Implementation |
| Frameworks & Drivers | フレームワーク・ドライバ・外部サービス | Web Framework, ORM, External API Client, Message Broker |

### 7.4 依存性ルール

#### 7.4.1 基本原則

**表11 — 依存性の基本原則**
| 原則 | 説明 |
|-----|------|
| 依存の方向 | 依存は外側から内側への一方向のみ許可する。内側の層は外側の層を知ってはならない |
| 依存性逆転原則（DIP） | 外側の層の具象に依存する場合は、内側の層でインタフェースを定義し、外側の層で実装する |
| 境界を越えるデータ | 層の境界を越えるデータは、シンプルなDTO（Data Transfer Object）を使用する |

#### 7.4.2 依存関係の例

**表12 — 依存関係の許可/禁止**
| 依存元 | 依存先 | 許可/禁止 |
|--------|--------|----------|
| Controller | Use Case (Input Port) | 許可 |
| Use Case | Entity / Value Object | 許可 |
| Use Case | Repository Interface | 許可 |
| Entity | Use Case | **禁止** |
| Entity | Controller | **禁止** |
| Repository Implementation | Repository Interface | 許可（DIP） |
| Entity | Framework | **禁止** |

### 7.5 ポートとアダプタ

**表13 — ポートとアダプタ**
| 要素 | 説明 | 配置層 |
|-----|------|--------|
| Input Port | ユースケースへの入力インタフェース | Application |
| Output Port | ユースケースからの出力インタフェース（Repository等） | Application |
| Primary Adapter | 外部からの入力を受け付けるアダプタ（Controller等） | Interface Adapters |
| Secondary Adapter | 外部への出力を行うアダプタ（Repository実装、API Client等） | Interface Adapters |

---

## 第8章 ドメインモデル設計方針

### 8.1 集約設計の原則

**表14 — 集約設計原則**
| 原則 | 説明 |
|-----|------|
| 整合性境界 | 集約はトランザクション整合性の境界を形成する。集約内の整合性はトランザクションで保証しなければならない |
| 集約ルート | 集約へのアクセスは必ず集約ルートを通じて行わなければならない |
| 小さな集約 | 集約は可能な限り小さく設計し、パフォーマンスとスケーラビリティを確保することが望ましい |
| 集約間の参照 | 集約間の参照はIDによる間接参照とし、オブジェクト参照を禁止する |
| 結果整合性 | 集約間の整合性は結果整合性（Eventual Consistency）で実現することを検討する |

### 8.2 エンティティ設計の原則

**表15 — エンティティ設計原則**
| 原則 | 説明 |
|-----|------|
| 識別子 | エンティティは一意な識別子を持ち、識別子で同一性を判定しなければならない |
| ライフサイクル | エンティティは生成・更新・削除のライフサイクルを持つ |
| 振る舞い | エンティティは自身の状態を変更する振る舞いを持ち、ドメインロジックをカプセル化しなければならない |
| 不変条件 | エンティティは常に不変条件（Invariant）を満たす状態でなければならない |

### 8.3 値オブジェクト設計の原則

**表16 — 値オブジェクト設計原則**
| 原則 | 説明 |
|-----|------|
| イミュータブル | 値オブジェクトは生成後に状態を変更してはならない |
| 等価性 | 値オブジェクトは属性の組み合わせで等価性を判定しなければならない |
| 自己完結 | 値オブジェクトは自身の妥当性検証ロジックを持つことが望ましい |
| 副作用なし | 値オブジェクトのメソッドは副作用を持たず、新しい値オブジェクトを返さなければならない |
| ユビキタス言語 | 値オブジェクトはユビキタス言語の語彙を表現することが望ましい |

### 8.4 ドメインサービス設計の原則

**表17 — ドメインサービス設計原則**
| 原則 | 説明 |
|-----|------|
| ステートレス | ドメインサービスは状態を持ってはならない |
| エンティティ・VOに属さないロジック | 複数の集約にまたがる、または特定のエンティティ・VOに属さないドメインロジックを配置する |
| ドメイン層配置 | ドメインサービスはドメイン層に配置しなければならない（アプリケーションサービスとは異なる） |
| インタフェース定義 | 外部依存がある場合は、ドメイン層でインタフェースを定義しなければならない |

---

## 第9章 CQRS方針

### 9.1 CQRS採用の目的

本システムでは、監査ログ・アプリケーションログ等の参照系処理において、\
コマンド（更新）とクエリ（参照）を分離するCQRS（Command Query Responsibility Segregation）パターンの適用を検討する。

**表18 — CQRS採用目的**
| 目的 | 説明 |
|-----|------|
| 読み書きの最適化 | 更新系と参照系で異なるデータモデル・ストレージを使用し、それぞれを最適化する |
| スケーラビリティ | 参照系のスケールアウトを独立して行えるようにする |
| 複雑なクエリの実現 | 複雑な集計・検索要件を、正規化されたドメインモデルに影響を与えずに実現する |
| パフォーマンス | 参照系を非正規化されたビューで最適化し、応答性能を向上させる |

### 9.2 CQRS適用範囲

**表19 — CQRS適用範囲**
| 適用対象 | 説明 |
|---------|------|
| 監査ログ参照 | 監査ログの検索・集計・レポート出力 |
| アプリケーションログ参照 | アプリケーションログの検索・分析 |
| 過去データ参照 | 履歴データの検索・集計（必要に応じて検討） |

上記以外の一般的なCRUD操作については、CQRSの適用は必須ではない。

### 9.3 CQRS設計方針

#### 9.3.1 コマンドモデル（更新系）

**表20 — コマンドモデル原則**
| 原則 | 説明 |
|-----|------|
| ドメインモデル使用 | 更新系はドメインモデル（集約）を通じて処理しなければならない |
| 整合性担保 | トランザクション整合性を集約単位で担保しなければならない |
| イベント発行 | 状態変更時にドメインイベントを発行し、クエリモデルの更新をトリガーすることが望ましい |

#### 9.3.2 クエリモデル（参照系）

**表21 — クエリモデル原則**
| 原則 | 説明 |
|-----|------|
| 読み取り専用 | クエリモデルは読み取り専用とし、更新を行ってはならない |
| 非正規化 | 参照要件に最適化された非正規化構造を許容する |
| 結果整合性 | コマンドモデルとの整合性は結果整合性で実現してもよい |
| プロジェクション | ドメインイベントを購読し、クエリモデル（プロジェクション）を更新することが望ましい |

### 9.4 イベントソーシングの検討

監査証跡が重要なデータについては、イベントソーシングパターンの適用を検討する。\
ただし、全BCへの一律適用は行わず、要件に応じてBC単位で検討しなければならない。

**表22 — イベントソーシング検討観点**
| 検討観点 | 説明 |
|---------|------|
| 監査要件 | すべての状態変化を追跡する必要がある場合に検討する |
| 複雑性 | イベントソーシングの複雑性とメリットを比較検討しなければならない |
| 既存資産 | 既存のデータモデル・運用との整合性を考慮しなければならない |

---

## 第10章 SBE/Living Documentation方針

### 10.1 SBE採用の目的

本システムでは、仕様書の陳腐化を防止し、仕様とコードの整合性を継続的に保証するため、\
SBE（Specification by Example）に基づくLiving Documentationを採用する。

**表23 — SBE採用目的**
| 目的 | 説明 |
|-----|------|
| 仕様の陳腐化防止 | 実行可能な仕様により、仕様書とコードの乖離を防止する |
| 共通理解の形成 | 具体例を用いた仕様定義により、ステークホルダー間の共通理解を形成する |
| 継続的な検証 | テスト実行により、仕様の正しさを継続的に検証する |
| ドキュメントの自動生成 | テスト結果からドキュメントを自動生成し、常に最新の状態を維持する |

### 10.2 仕様定義の二元管理

本システムでは、仕様を「振る舞い」と「構造」に分離して管理する。

**表24 — 仕様定義の二元管理**
| 区分 | 定義形式 | 管理単位 | 説明 |
|-----|---------|---------|------|
| 振る舞い | Gherkin（.feature） | BC単位 | ユースケース・ビジネスルールの振る舞いを具体例で定義する |
| 構造 | 仕様書（Markdown等） | BC単位 | エンティティ・VO・集約の構造・属性を定義する |

### 10.3 Gherkinによる振る舞い定義

#### 10.3.1 Gherkin記述方針

**表25 — Gherkin記述原則**
| 原則 | 説明 |
|-----|------|
| ユビキタス言語 | Gherkinのシナリオはユビキタス言語で記述しなければならない |
| ビジネス視点 | 技術的な実装詳細ではなく、ビジネスの視点でシナリオを記述しなければならない |
| 具体例 | 抽象的なルールではなく、具体的な例（値）を用いて記述しなければならない |
| 独立性 | 各シナリオは他のシナリオに依存せず、独立して実行可能でなければならない |

#### 10.3.2 Gherkinファイルの管理

**表26 — Gherkinファイル管理方針**
| 項目 | 方針 |
|-----|------|
| 配置場所 | BC単位のディレクトリに配置しなければならない |
| 命名規則 | フィーチャー名は対応するユースケース・ドメインルールと整合させなければならない |
| バージョン管理 | ソースコードと同一リポジトリで管理し、変更履歴を追跡可能にしなければならない |

### 10.4 Living Documentationの原則

#### 10.4.1 基本原則

**表27 — Living Documentation基本原則**
| 原則 | 説明 |
|-----|------|
| 実行可能な仕様 | Gherkinシナリオは自動テストとして実行可能でなければならない |
| テスト = 仕様検証 | テストの成功は、仕様が正しく実装されていることを保証する |
| 失敗 = 乖離検出 | テストの失敗は、仕様とコードの乖離を検出する手段である |
| 継続的実行 | CI/CDパイプラインでGherkinテストを継続的に実行しなければならない |

#### 10.4.2 仕様変更時のルール

**表28 — 仕様変更時ルール**
| ルール | 説明 |
|-------|------|
| Gherkin先行 | ビジネスルール変更時は、まずGherkinシナリオを更新しなければならない |
| テスト失敗の受容 | Gherkin更新後、対応するテストが失敗することを確認しなければならない |
| 実装による修正 | テストが通るように実装を修正する（TDDサイクル） |
| 仕様書同期 | 構造に影響がある場合は、構造仕様書も同時に更新しなければならない |

### 10.5 ソース生成フローとTDD連携

#### 10.5.1 開発フロー
```
┌──────────────────────────────────────────────────────────────────┐
│                      開発フロー                                   │
│                                                                  │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐      │
│  │ 構造仕様 │───▶│ソース生成│───▶│ Gherkin │───▶│  TDD    │      │
│  │ 定義    │    │(構造)   │    │シナリオ │    │ サイクル │      │
│  └─────────┘    └─────────┘    └─────────┘    └─────────┘      │
│       │                              │              │            │
│       │                              ▼              ▼            │
│       │                        ┌─────────┐   ┌─────────┐       │
│       │                        │ステップ  │   │ユニット │       │
│       │                        │定義生成  │   │テスト   │       │
│       │                        └─────────┘   └─────────┘       │
│       │                              │              │            │
│       │                              ▼              ▼            │
│       │                        ┌─────────────────────┐          │
│       └───────────────────────▶│  Living Document    │          │
│                                │  (常に最新の仕様)   │          │
│                                └─────────────────────┘          │
└──────────────────────────────────────────────────────────────────┘
```

#### 10.5.2 生成と手動実装の役割分担

**表29 — 生成と手動実装の役割分担**
| 区分 | 生成対象 | 手動実装対象 |
|-----|---------|-------------|
| 構造 | エンティティ・VOのスケルトン、DTO | ドメインロジック、ビジネスルール |
| 振る舞い | Gherkinステップ定義のスケルトン | ステップ内の具体的な検証・操作 |
| テスト | テストクラスのスケルトン | テストケースの実装 |

#### 10.5.3 仕様とコードの同期保証

**表30 — 仕様とコードの同期保証**
| 保証項目 | 方法 |
|---------|------|
| 振る舞いの同期 | Gherkinテストの継続的実行により、振る舞い仕様とコードの同期を保証する |
| 構造の同期 | 構造仕様からの再生成と差分検出により、構造仕様とコードの同期を検証する |
| 乖離の検出 | CI/CDでの自動検証により、仕様とコードの乖離を早期に検出する |
