---
id: ARCZZZZ001
title: ソフトウェアアーキテクチャ方針書
sidebar_position: 1
---

# ソフトウェアアーキテクチャ方針書

| 項目 | 内容 |
|------|------|
| ドキュメントID | ARCZZZZ001 |
| 版数 | 1.0 |
| 作成日 | 2026-01-14 |
| 最終更新日 | 2026-01-14 |
| ステータス | ドラフト |

---

## 第1章 適用範囲

### 1.1 目的

本書は、ハウスクレジット基幹システムにおけるソフトウェアアーキテクチャの共通方針を定め、DDD（ドメイン駆動設計）およびクリーンアーキテクチャに基づく設計・実装の一貫性を確保することを目的とする。

本書で定義されたアーキテクチャ方針に反する設計・実装を行ってはならない。

### 1.2 適用範囲

**表1 — 適用範囲**

| 項目 | 記述内容 |
|------|----------|
| 対象システム | ハウスクレジット基幹システム |
| 対象BC | ドメインスコープ定義書およびコンテキストマップに定義された全BC |
| 除外対象 | 未確定（PoC／一時検証用コンポーネントは例外承認対象とする想定だが詳細運用ルールは未確定） |

### 1.3 関連文書

本書は「システム全体方針検討」に属するアーキテクチャ指針であり、以下のドキュメントと連携する。

**表2 — 関連文書一覧**

| 関連ドキュメント | 関係性 |
|------------------|--------|
| ドメインスコープ定義書 | BC構造・境界の定義をインプットとする |
| コンテキストマップ | BC間関係の定義をインプットとする |
| データモデリング方針書 | 永続化層の設計方針と整合する |
| APIガバナンス方針書 | API設計方針と整合する |
| 非同期連携方針書 | BC間連携の詳細を参照する |
| テスト・品質保証方針書 | SBE/TDDの詳細を参照する |

BC間連携の詳細方針は別ドキュメント（非同期連携方針書、APIガバナンス方針書等）で定義し、本書ではDDD・クリーンアーキテクチャの基本的な考え方のみを定義する。

---

## 第2章 引用規格

本書は以下の規格・標準を参照する：

- ISO/IEC 25010:2011 システム及びソフトウェア品質モデル
- IEEE 1471-2000 ソフトウェア集約システムのアーキテクチャ記述

---

## 第3章 用語及び定義

本書で使用する主要な用語を以下に定義する。

**表3 — 用語定義**

| 用語 | 定義 |
|------|------|
| BC（Bounded Context） | DDDにおける境界づけられたコンテキスト。モデルの適用範囲を明確に区切る境界 |
| 集約（Aggregate） | 整合性境界を形成するエンティティ・VOの集まり |
| ユビキタス言語 | ドメインエキスパートと開発者が共通して使用する言語 |
| クリーンアーキテクチャ | 依存関係を内側に向けることで、ドメインロジックを外部依存から保護するアーキテクチャ |
| CQRS | Command Query Responsibility Segregation（コマンドクエリ責務分離） |
| SBE | Specification by Example（実例による仕様記述） |
| Living Documentation | 実行可能なテストとして維持される、常に最新のドキュメント |
| DDD | Domain-Driven Design（ドメイン駆動設計） |
| エンティティ | 識別子を持ち、ライフサイクルを通じて同一性が維持されるオブジェクト |
| 値オブジェクト（VO） | 識別子を持たず、属性の組み合わせで同一性が判定されるオブジェクト |

---

## 第4章 対象BC一覧

コンテキストマップより抽出した対象BC一覧を以下に示す。

**表4 — 対象BC一覧**

| No. | ドメイン | サブドメイン | BC | BC概要 |
|-----|----------|--------------|-----|--------|
| 1 | 売上管理 | 売上取込 | 売上取込BC | ブランド/ネットワークからの売上受入・重複/形式チェック |
| 2 | 売上管理 | 売上確定 | 売上確定BC | 審査後の売上確定・取消制御・請求連携の起点 |
| 3 | 売上管理 | オーソリ反映 | オーソリ反映BC | オーソリ結果・解約等に伴う即時利用可否反映（詳細未確定） |
| 4 | 会員精算管理 | 請求管理 | 請求BC | サイクル集計・請求締め・会計連携候補の生成 |
| 5 | 会員精算管理 | 入金管理 | 入金BC | 口座振替/全銀振込の結果取込・消込・未収管理 |
| 6 | 会員精算管理 | 返金処理 | 返金BC | 返金起案/承認/実行と結果反映 |
| 7 | ポイント管理 | ポイント管理 | ポイントBC | 売上連携によるポイント付与/利用/失効・履歴管理 |
| 8 | 審査発行管理 | 与信審査 | 審査BC | 申込〜eKYC/信用照会〜審査判定 |
| 9 | 審査発行管理 | カード発行 | 発行BC | 発番・印刷・発送・受領管理 |
| 10 | 加盟店契約管理 | 契約/審査 | 加盟店契約BC | 加盟店申請→名寄せ→登録、属性/契約変更・停止/解約 |
| 11 | 加盟店契約管理 | 契約/審査 | 加盟店審査BC | 加盟店審査・外部信用情報機関への照会 |
| 12 | 会計統合管理 | 日計/会計連携 | 日計管理BC | 仕訳基準・日計管理 |
| 13 | 会計統合管理 | 日計/会計連携 | 会計連携BC | 会計連携用I/F加工（外部会計システム連携） |
| 14 | 共通運用管理 | 共通マスタ/日付 | 共通マスターBC | 住所・金融・コード・休日など共通マスタ（全ドメイン参照） |
| 15 | 共通運用管理 | 共通マスタ/日付 | 運用日付BC | システム日付等の運用日付管理 |
| 16 | 顧客管理 | 顧客 | 顧客BC | 顧客基本情報管理（詳細未確定） |
| 17 | 顧客管理 | 連絡先・住所 | 連絡先・住所BC | 顧客の連絡先・住所情報管理（共通マスターBCとShared Kernel） |
| 18 | 顧客管理 | 解約 | 解約BC | 解約登録・利用停止トリガ管理 |

---

## 第5章 アーキテクチャ基本方針（DDD）

### 5.1 DDD採用の目的

本システムでは、複雑なビジネスドメインを適切にモデル化し、ソフトウェアの構造とビジネスの構造を一致させるため、DDD（ドメイン駆動設計）を採用する。

**表5 — DDD採用目的**

| 目的 | 説明 |
|------|------|
| ビジネスとコードの整合 | ユビキタス言語を通じて、ドメインエキスパートと開発者の共通理解を形成する |
| 複雑性の管理 | BCによる境界の明確化で、複雑なドメインを管理可能な単位に分割する |
| 変更容易性 | ドメインモデルの独立性により、ビジネス変更に追従しやすい構造を実現する |
| 自律性の確保 | BC単位での独立した開発・デプロイを可能にする |

### 5.2 戦略的設計の原則

#### 5.2.1 境界づけられたコンテキスト（Bounded Context）

**表6 — BC設計原則**

| 原則 | 説明 |
|------|------|
| BC単位のモデル | 各BCは独自のドメインモデルを持ち、他BCのモデルを直接参照してはならない |
| ユビキタス言語の範囲 | ユビキタス言語はBC内で一貫性を持ち、BC間では同じ用語が異なる意味を持つことを許容する |
| 自律性 | 各BCは独立してデプロイ・スケール可能な単位として設計しなければならない |
| データベース分離 | 各BCは原則として独自のデータベーススキーマを持つことが望ましい |

#### 5.2.2 コンテキスト間関係の基本パターン

BC間の関係は、コンテキストマップで定義されたパターンに従う。詳細は別ドキュメントで定義するが、基本パターンは以下の通り。

**表7 — コンテキスト間関係パターン**

| パターン | 説明 | 適用場面 |
|---------|------|----------|
| ACL（Anti-Corruption Layer） | 外部システムやレガシーシステムとの連携時に、翻訳層を設けて自BCのモデルを保護する | 外部会計システム、銀行口座振替API等との連携 |
| Shared Kernel | 複数BCで共有する小さなモデルを定義し、共同で管理する | 連絡先・住所BCと共通マスターBC |
| Customer/Supplier | 上流BC（Supplier）が下流BC（Customer）の要求に応じてAPIを提供する | BC間の依存関係がある場合 |
| Published Language | 標準化されたスキーマ・プロトコルでBC間を連携する | イベント駆動連携 |
| Conformist | 下流BCが上流BCのモデルをそのまま受け入れる | 変更不可能な外部システムとの連携 |

### 5.3 戦術的設計の原則

#### 5.3.1 ドメインモデルの構成要素

**表8 — ドメインモデル構成要素**

| 要素 | 説明 | 設計上の注意点 |
|------|------|---------------|
| エンティティ（Entity） | 識別子を持ち、ライフサイクルを通じて同一性が維持されるオブジェクト | 識別子による同一性判定、状態変化を許容 |
| 値オブジェクト（Value Object） | 識別子を持たず、属性の組み合わせで同一性が判定されるオブジェクト | イミュータブル、等価性による比較、副作用なし |
| 集約（Aggregate） | 整合性境界を形成するエンティティ・VOの集まり | トランザクション整合性の単位、集約ルートを通じてのみアクセス |
| ドメインサービス | エンティティ・VOに属さないドメインロジック | ステートレス、ドメイン層に配置 |
| ドメインイベント | ドメイン内で発生した重要な出来事 | 過去形で命名、イミュータブル |
| リポジトリ | 集約の永続化・取得を担う抽象 | ドメイン層にインタフェース、インフラ層に実装 |
| ファクトリ | 複雑な集約の生成を担う | 生成ロジックのカプセル化 |

---

## 第6章 クリーンアーキテクチャ方針

### 6.1 クリーンアーキテクチャ採用の目的

本システムでは、フレームワーク・データベース・UIに依存しないドメインモデルを実現するため、クリーンアーキテクチャを採用する。

**表9 — クリーンアーキテクチャ採用目的**

| 目的 | 説明 |
|------|------|
| フレームワーク非依存 | ドメインロジックがフレームワークに依存せず、技術変更に強い構造を実現する |
| テスタビリティ | ドメインロジックを外部依存なしにテスト可能にする |
| UI非依存 | UIの変更がドメインロジックに影響を与えない |
| DB非依存 | データベースの変更がドメインロジックに影響を与えない |
| 外部サービス非依存 | 外部サービスの変更がドメインロジックに影響を与えない |

### 6.2 同心円構造の定義

クリーンアーキテクチャの同心円構造を以下のように定義する。内側の層は外側の層に依存してはならない。

```
┌─────────────────────────────────────────────────────────────┐
│              Frameworks & Drivers (Layer 4)                 │
│  (Web Framework, DB, External Services, UI)                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │          Interface Adapters (Layer 3)                │   │
│  │  (Controllers, Presenters, Gateways, Repositories)  │   │
│  │  ┌─────────────────────────────────────────────┐    │   │
│  │  │          Application (Layer 2)               │    │   │
│  │  │           (Use Cases)                       │    │   │
│  │  │  ┌─────────────────────────────────────┐   │    │   │
│  │  │  │         Domain (Layer 1)             │   │    │   │
│  │  │  │  (Entities, Value Objects,          │   │    │   │
│  │  │  │   Domain Services, Domain Events)   │   │    │   │
│  │  │  └─────────────────────────────────────┘   │    │   │
│  │  └─────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘

依存の方向: Layer 4 → Layer 3 → Layer 2 → Layer 1
```

### 6.3 各層の責務と配置要素

**表10 — 各層の責務と配置要素**

| 層 | 責務 | 配置要素 | 依存可能な層 |
|----|------|----------|------------|
| Layer 1: エンティティ層（Domain） | ビジネスルール・ドメインロジックの表現 | Entity, Value Object, Domain Service, Domain Event, Repository Interface, Factory Interface | なし（完全に独立） |
| Layer 2: ユースケース層（Application） | ユースケースの実現、アプリケーション固有のビジネスルール | Use Case (Interactor), Input Port, Output Port, Application Service | Layer 1のみ |
| Layer 3: アダプタ層（Interface Adapters） | 外部との入出力の変換 | Controller, Presenter, Gateway Implementation, Repository Implementation | Layer 1, 2 |
| Layer 4: 外部フレームワークとドライバー | フレームワーク・ドライバ・外部サービス | Web Framework, ORM, External API Client, Message Broker, UI Components | Layer 1, 2, 3 |

### 6.4 依存性ルール

#### 6.4.1 基本原則

**表11 — 依存性の基本原則**

| 原則 | 説明 |
|------|------|
| 依存の方向 | 依存は外側から内側への一方向のみ許可する。内側の層は外側の層を知ってはならない |
| 依存性逆転原則（DIP） | 外側の層の具象に依存する場合は、内側の層でインタフェースを定義し、外側の層で実装する |
| 境界を越えるデータ | 層の境界を越えるデータは、シンプルなDTO（Data Transfer Object）を使用する |
| フレームワーク独立性 | ドメイン層およびユースケース層は、特定のフレームワークに依存してはならない |

#### 6.4.2 依存関係の許可/禁止

**表12 — 依存関係の許可/禁止**

| 依存元 | 依存先 | 許可/禁止 | 備考 |
|--------|--------|----------|------|
| Controller | Use Case (Input Port) | 許可 | 適切な依存 |
| Use Case | Entity / Value Object | 許可 | 適切な依存 |
| Use Case | Repository Interface | 許可 | DIPにより実現 |
| Entity | Use Case | **禁止** | 依存の逆転 |
| Entity | Controller | **禁止** | 依存の逆転 |
| Entity | Framework | **禁止** | フレームワーク依存 |
| Repository Implementation | Repository Interface | 許可 | DIPの実装側 |
| Repository Implementation | Entity | 許可 | エンティティの永続化 |
| Domain Service | Entity / Value Object | 許可 | 適切な依存 |

### 6.5 ポートとアダプタ

ヘキサゴナルアーキテクチャの概念を統合し、ポートとアダプタを明確に定義する。

**表13 — ポートとアダプタ**

| 要素 | 説明 | 配置層 | 例 |
|------|------|--------|-----|
| Input Port（駆動ポート） | ユースケースへの入力インタフェース | Application | CreateOrderUseCase（インタフェース） |
| Output Port（被駆動ポート） | ユースケースからの出力インタフェース | Application | OrderRepository（インタフェース）、PaymentGateway（インタフェース） |
| Primary Adapter（駆動アダプタ） | 外部からの入力を受け付けるアダプタ | Interface Adapters | REST Controller, GraphQL Resolver, CLI Handler |
| Secondary Adapter（被駆動アダプタ） | 外部への出力を行うアダプタ | Interface Adapters | JPA Repository Implementation, External API Client |

---

## 第7章 ドメインモデル設計方針

### 7.1 集約設計の原則

集約は、トランザクション整合性を保証する境界として重要な役割を果たす。

**表14 — 集約設計原則**

| 原則 | 説明 |
|------|------|
| 整合性境界 | 集約はトランザクション整合性の境界を形成する。集約内の整合性はトランザクションで保証しなければならない |
| 集約ルート | 集約へのアクセスは必ず集約ルートを通じて行わなければならない。集約内部のエンティティへの直接アクセスを禁止する |
| 小さな集約 | 集約は可能な限り小さく設計し、パフォーマンスとスケーラビリティを確保することが望ましい |
| 集約間の参照 | 集約間の参照はIDによる間接参照とし、オブジェクト参照を禁止する |
| 結果整合性 | 集約間の整合性は結果整合性（Eventual Consistency）で実現することを検討する |
| 不変条件の保護 | 集約は常に不変条件（Invariant）を満たす状態でなければならない |
| 単一トランザクション | 1トランザクションで1集約のみを変更することが望ましい |

### 7.2 エンティティ設計の原則

**表15 — エンティティ設計原則**

| 原則 | 説明 |
|------|------|
| 識別子 | エンティティは一意な識別子を持ち、識別子で同一性を判定しなければならない |
| ライフサイクル | エンティティは生成・更新・削除のライフサイクルを持つ |
| 振る舞い | エンティティは自身の状態を変更する振る舞いを持ち、ドメインロジックをカプセル化しなければならない |
| 不変条件 | エンティティは常に不変条件（Invariant）を満たす状態でなければならない |
| セッター禁止 | 単純なセッターメソッドは提供せず、ビジネスの意図を表すメソッドを定義しなければならない |
| ドメインイベント発行 | 重要な状態変更時にはドメインイベントを発行することが望ましい |

### 7.3 値オブジェクト設計の原則

**表16 — 値オブジェクト設計原則**

| 原則 | 説明 |
|------|------|
| イミュータブル | 値オブジェクトは生成後に状態を変更してはならない |
| 等価性 | 値オブジェクトは属性の組み合わせで等価性を判定しなければならない |
| 自己完結 | 値オブジェクトは自身の妥当性検証ロジックを持つことが望ましい |
| 副作用なし | 値オブジェクトのメソッドは副作用を持たず、新しい値オブジェクトを返さなければならない |
| ユビキタス言語 | 値オブジェクトはユビキタス言語の語彙を表現することが望ましい |
| プリミティブ回避 | プリミティブ型の多用を避け、意味のある値オブジェクトにすることが望ましい |
| バリデーション | 生成時にバリデーションを実施し、不正な状態のVOが存在しないようにしなければならない |

### 7.4 ドメインサービス設計の原則

**表17 — ドメインサービス設計原則**

| 原則 | 説明 |
|------|------|
| ステートレス | ドメインサービスは状態を持ってはならない |
| エンティティ・VOに属さないロジック | 複数の集約にまたがる、または特定のエンティティ・VOに属さないドメインロジックを配置する |
| ドメイン層配置 | ドメインサービスはドメイン層に配置しなければならない（アプリケーションサービスとは異なる） |
| インタフェース定義 | 外部依存がある場合は、ドメイン層でインタフェースを定義しなければならない |
| 命名規則 | ドメインサービスの名前はユビキタス言語に基づき、ビジネスの意図を表現しなければならない |

### 7.5 ドメインイベント設計の原則

**表18 — ドメインイベント設計原則**

| 原則 | 説明 |
|------|------|
| 過去形命名 | ドメインイベントは過去形で命名しなければならない（例：OrderPlaced、PaymentCompleted） |
| イミュータブル | ドメインイベントは生成後に状態を変更してはならない |
| ビジネス視点 | 技術的な出来事ではなく、ビジネス上重要な出来事を表現しなければならない |
| タイムスタンプ | イベント発生日時を含めなければならない |
| コンテキスト情報 | イベントに関連する最小限のコンテキスト情報を含めることが望ましい |

---

## 第8章 CQRS方針

### 8.1 CQRS採用の目的

本システムでは、監査ログ・アプリケーションログ等の参照系処理において、コマンド（更新）とクエリ（参照）を分離するCQRS（Command Query Responsibility Segregation）パターンの適用を検討する。

**表19 — CQRS採用目的**

| 目的 | 説明 |
|------|------|
| 読み書きの最適化 | 更新系と参照系で異なるデータモデル・ストレージを使用し、それぞれを最適化する |
| スケーラビリティ | 参照系のスケールアウトを独立して行えるようにする |
| 複雑なクエリの実現 | 複雑な集計・検索要件を、正規化されたドメインモデルに影響を与えずに実現する |
| パフォーマンス | 参照系を非正規化されたビューで最適化し、応答性能を向上させる |
| 責務の分離 | 更新と参照の責務を明確に分離し、それぞれに最適な設計を適用する |

### 8.2 CQRS適用範囲

**表20 — CQRS適用範囲**

| 適用対象 | 適用理由 | 優先度 |
|---------|---------|--------|
| 監査ログ参照 | 監査ログの検索・集計・レポート出力の最適化 | 高 |
| アプリケーションログ参照 | アプリケーションログの検索・分析の最適化 | 高 |
| 過去データ参照 | 履歴データの検索・集計（必要に応じて検討） | 中 |
| ダッシュボード・レポート | 複雑な集計を要するレポートの最適化 | 中 |

上記以外の一般的なCRUD操作については、CQRSの適用は必須ではない。適用の要否はBC単位で判断してもよい。

### 8.3 CQRS設計方針

#### 8.3.1 コマンドモデル（更新系）

**表21 — コマンドモデル原則**

| 原則 | 説明 |
|------|------|
| ドメインモデル使用 | 更新系はドメインモデル（集約）を通じて処理しなければならない |
| 整合性担保 | トランザクション整合性を集約単位で担保しなければならない |
| イベント発行 | 状態変更時にドメインイベントを発行し、クエリモデルの更新をトリガーすることが望ましい |
| ビジネスルール実行 | すべてのビジネスルールはコマンドモデル側で実行しなければならない |

#### 8.3.2 クエリモデル（参照系）

**表22 — クエリモデル原則**

| 原則 | 説明 |
|------|------|
| 読み取り専用 | クエリモデルは読み取り専用とし、更新を行ってはならない |
| 非正規化 | 参照要件に最適化された非正規化構造を許容する |
| 結果整合性 | コマンドモデルとの整合性は結果整合性で実現してもよい |
| プロジェクション | ドメインイベントを購読し、クエリモデル（プロジェクション）を更新することが望ましい |
| 複数ビュー | 同一データに対して複数の最適化されたビューを持つことを許容する |

### 8.4 イベントソーシングの検討

監査証跡が重要なデータについては、イベントソーシングパターンの適用を検討する。ただし、全BCへの一律適用は行わず、要件に応じてBC単位で検討しなければならない。

**表23 — イベントソーシング検討観点**

| 検討観点 | 説明 |
|---------|------|
| 監査要件 | すべての状態変化を追跡する必要がある場合に検討する |
| 時間旅行クエリ | 過去の任意時点の状態を再現する必要がある場合に検討する |
| 複雑性 | イベントソーシングの複雑性とメリットを比較検討しなければならない |
| 既存資産 | 既存のデータモデル・運用との整合性を考慮しなければならない |
| パフォーマンス | イベント再生のパフォーマンスを考慮しなければならない |

---

## 第9章 SBE/Living Documentation方針

### 9.1 SBE採用の目的

本システムでは、仕様書の陳腐化を防止し、仕様とコードの整合性を継続的に保証するため、SBE（Specification by Example）に基づくLiving Documentationを採用する。

**表24 — SBE採用目的**

| 目的 | 説明 |
|------|------|
| 仕様の陳腐化防止 | 実行可能な仕様により、仕様書とコードの乖離を防止する |
| 共通理解の形成 | 具体例を用いた仕様定義により、ステークホルダー間の共通理解を形成する |
| 継続的な検証 | テスト実行により、仕様の正しさを継続的に検証する |
| ドキュメントの自動生成 | テスト結果からドキュメントを自動生成し、常に最新の状態を維持する |

### 9.2 仕様定義の二元管理

本システムでは、仕様を「振る舞い」と「構造」に分離して管理する。

**表25 — 仕様定義の二元管理**

| 区分 | 定義形式 | 管理単位 | 説明 |
|------|---------|---------|------|
| 振る舞い | Gherkin（.feature） | BC単位 | ユースケース・ビジネスルールの振る舞いを具体例で定義する |
| 構造 | 仕様書（Markdown等） | BC単位 | エンティティ・VO・集約の構造・属性を定義する |

### 9.3 Gherkinによる振る舞い定義

#### 9.3.1 Gherkin記述方針

**表26 — Gherkin記述原則**

| 原則 | 説明 |
|------|------|
| ユビキタス言語 | Gherkinのシナリオはユビキタス言語で記述しなければならない |
| ビジネス視点 | 技術的な実装詳細ではなく、ビジネスの視点でシナリオを記述しなければならない |
| 具体例 | 抽象的なルールではなく、具体的な例（値）を用いて記述しなければならない |
| 独立性 | 各シナリオは他のシナリオに依存せず、独立して実行可能でなければならない |
| Given-When-Then | Given（前提条件）、When（操作）、Then（期待結果）の形式で記述しなければならない |

#### 9.3.2 Gherkinファイルの管理

**表27 — Gherkinファイル管理方針**

| 項目 | 方針 |
|------|------|
| 配置場所 | BC単位のディレクトリに配置しなければならない |
| 命名規則 | フィーチャー名は対応するユースケース・ドメインルールと整合させなければならない |
| バージョン管理 | ソースコードと同一リポジトリで管理し、変更履歴を追跡可能にしなければならない |
| レビュー | Gherkinシナリオはドメインエキスパートと共にレビューしなければならない |

### 9.4 Living Documentationの原則

#### 9.4.1 基本原則

**表28 — Living Documentation基本原則**

| 原則 | 説明 |
|------|------|
| 実行可能な仕様 | Gherkinシナリオは自動テストとして実行可能でなければならない |
| テスト = 仕様検証 | テストの成功は、仕様が正しく実装されていることを保証する |
| 失敗 = 乖離検出 | テストの失敗は、仕様とコードの乖離を検出する手段である |
| 継続的実行 | CI/CDパイプラインでGherkinテストを継続的に実行しなければならない |
| ドキュメント生成 | テスト結果からHTMLレポート等のドキュメントを自動生成することが望ましい |

#### 9.4.2 仕様変更時のルール

**表29 — 仕様変更時ルール**

| ルール | 説明 |
|-------|------|
| Gherkin先行 | ビジネスルール変更時は、まずGherkinシナリオを更新しなければならない |
| テスト失敗の受容 | Gherkin更新後、対応するテストが失敗することを確認しなければならない |
| 実装による修正 | テストが通るように実装を修正する（TDDサイクル） |
| 仕様書同期 | 構造に影響がある場合は、構造仕様書も同時に更新しなければならない |

### 9.5 TDD連携

**表30 — TDDとの連携**

| 項目 | 方針 |
|------|------|
| ユニットテスト | エンティティ・VOのビジネスロジックはユニットテストで検証しなければならない |
| 統合テスト | ユースケース層の振る舞いは統合テストで検証しなければならない |
| Gherkinテスト | エンドツーエンドの振る舞いはGherkinテストで検証しなければならない |
| テストピラミッド | ユニットテスト > 統合テスト > E2Eテストのバランスを保つことが望ましい |

---

## 付録A 未確定事項一覧

本方針書において「未確定」と記載された事項を以下にまとめる。これらは後続の検討・合意形成により確定させなければならない。

**表A.1 — 未確定事項一覧**

| 章節 | 項目 | 備考 |
|------|------|------|
| 1.2 | PoC/一時検証用コンポーネントの例外承認ルール | 詳細運用ルールの策定が必要 |
| 4 | オーソリ反映BCの詳細 | BC定義の詳細化が必要 |
| 4 | 顧客BCの詳細 | BC定義の詳細化が必要 |
| 8.4 | イベントソーシングの適用BC | BC単位での適用可否判断が必要 |
| 9.5 | テストツールの選定 | Cucumber、SpecFlow等のツール選定が必要 |

---

## 付録B 検討が必要な論点

以下は、本方針書の運用にあたり検討が必要な論点である。

1. **BC間通信の実装方式**
   - 同期通信（REST API、gRPC）vs 非同期通信（メッセージング）の選択基準
   - イベント駆動アーキテクチャの適用範囲
   - Sagaパターンの実装方式

2. **データベース分離の程度**
   - BC単位での完全なDB分離 vs スキーマレベル分離 vs 論理的分離
   - Shared Kernelの実装方式（共有DB、レプリケーション、API経由）
   - マイクロサービス化の段階的アプローチ

3. **集約サイズの最適化**
   - パフォーマンス要件と整合性要件のバランス
   - 集約の分割/結合の判断基準
   - 結果整合性の許容範囲

4. **CQRS/イベントソーシングの導入範囲**
   - どのBCにCQRSを適用するか
   - イベントソーシングの適用可否
   - プロジェクション更新の信頼性確保

5. **技術スタックの選定**
   - プログラミング言語（Java、C#、Go等）
   - フレームワーク（Spring Boot、.NET等）
   - メッセージブローカー（Kafka、RabbitMQ、AWS SQS/SNS等）
   - データベース（RDB、NoSQL、イベントストア）

6. **開発生産性とアーキテクチャ原則のバランス**
   - ボイラープレートコードの削減
   - コード生成ツールの活用
   - アーキテクチャルールの自動検証

7. **既存システムからの移行戦略**
   - ストラングラーパターンの適用
   - ACLの実装範囲
   - データ移行アプローチ

8. **Gherkinテストの運用**
   - シナリオ数の管理（肥大化への対応）
   - 実行時間の最適化
   - ステップ定義の再利用戦略
   - ドメインエキスパートの関与プロセス

---
