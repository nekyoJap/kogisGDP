---
id: ARCZZZZ001
title: ソフトウェアアーキテクチャ方針書
sidebar_position: 1
---

# ソフトウェアアーキテクチャ方針書

| 項目 | 内容 |
|------|------|
| ドキュメントID | ARCZZZZ001 |
| 版数 | 1.1 |
| 作成日 | 2026-01-14 |
| 最終更新日 | 2026-01-15 |
| ステータス | ドラフト |

---

## 第1章 適用範囲

### 1.1 目的

本書は、ハウスクレジット基幹システムにおけるソフトウェアアーキテクチャの共通方針を定め、DDD（ドメイン駆動設計）およびクリーンアーキテクチャに基づく設計・実装の一貫性を確保することを目的とする。

本書で定義されたアーキテクチャ方針に反する設計・実装を行ってはならない。

### 1.2 適用範囲

**表1 — 適用範囲**

| 項目 | 記述内容 |
|------|----------|
| 対象システム | ハウスクレジット基幹システム |
| 対象BC | ドメインスコープ定義書およびコンテキストマップに定義された全BC |
| 除外対象 | 未確定（PoC／一時検証用コンポーネントは例外承認対象とする想定だが詳細運用ルールは未確定） |

### 1.3 技術スタック

本システムにおける技術スタックは以下の通りとする。

**表2 — 技術スタック**

| レイヤー | 技術 | バージョン | 備考 |
|---------|------|----------|------|
| バックエンド言語 | Java | 17以上（LTS） | OpenJDK推奨 |
| バックエンドフレームワーク | Spring Boot | 3.x | Spring Framework 6.x |
| フロントエンドフレームワーク | React | 18.x以上 | TypeScript必須 |
| ビルドツール（バックエンド） | Gradle または Maven | - | Gradle推奨 |
| ビルドツール（フロントエンド） | npm / Vite | - | - |
| APIスキーマ | OpenAPI 3.0 | - | REST API定義 |

### 1.4 関連文書

本書は「システム全体方針検討」に属するアーキテクチャ指針であり、以下のドキュメントと連携する。

**表3 — 関連文書一覧**

| 関連ドキュメント | 関係性 |
|------------------|--------|
| ドメインスコープ定義書 | BC構造・境界の定義をインプットとする |
| コンテキストマップ | BC間関係の定義をインプットとする |
| データモデリング方針書 | 永続化層の設計方針と整合する |
| APIガバナンス方針書 | API設計方針と整合する |
| 非同期連携方針書 | BC間連携の詳細を参照する |
| 例外処理ポリシー | エラーハンドリング方針を参照する |
| テスト・品質保証方針書 | SBE/TDDの詳細を参照する |
| セキュリティ方針書 | セキュリティ要件との整合を確保する |
| 認証・認可方針書 | 認証認可の実装方針を参照する |
| アプリケーションログ方針書 | ログ出力方針を参照する |
| トランザクション方針書 | トランザクション制御方針を参照する |

BC間連携の詳細方針は別ドキュメント（非同期連携方針書、APIガバナンス方針書等）で定義し、本書ではDDD・クリーンアーキテクチャの基本的な考え方のみを定義する。

---

## 第2章 引用規格

本書は以下の規格・標準を参照する：

- ISO/IEC 25010:2011 システム及びソフトウェア品質モデル
- IEEE 1471-2000 ソフトウェア集約システムのアーキテクチャ記述
- RFC 2119 Key words for use in RFCs to Indicate Requirement Levels

---

## 第3章 用語及び定義

### 3.1 規範用語の定義

本書で使用する規範用語は RFC 2119 に準拠し、以下の意味で使用する。

**表4 — 規範用語定義**

| 用語 | 意味 |
|------|------|
| しなければならない（MUST） | この要件は絶対的に必須である。例外は認められない |
| してはならない（MUST NOT） | この行為は絶対的に禁止される。例外は認められない |
| すべきである（SHOULD） | 特別な理由がない限り、この要件に従うことが強く推奨される |
| すべきではない（SHOULD NOT） | 特別な理由がない限り、この行為を避けることが強く推奨される |
| してもよい（MAY） | この要件は任意であり、状況に応じて判断してよい |

### 3.2 ドメイン用語の定義

本書で使用する主要な用語を以下に定義する。

**表5 — 用語定義**

| 用語 | 定義 |
|------|------|
| BC（Bounded Context） | DDDにおける境界づけられたコンテキスト。モデルの適用範囲を明確に区切る境界 |
| 集約（Aggregate） | 整合性境界を形成するエンティティ・VOの集まり |
| ユビキタス言語 | ドメインエキスパートと開発者が共通して使用する言語 |
| クリーンアーキテクチャ | 依存関係を内側に向けることで、ドメインロジックを外部依存から保護するアーキテクチャ |
| CQRS | Command Query Responsibility Segregation（コマンドクエリ責務分離） |
| SBE | Specification by Example（実例による仕様記述） |
| Living Documentation | 実行可能なテストとして維持される、常に最新のドキュメント |
| DDD | Domain-Driven Design（ドメイン駆動設計） |
| エンティティ | 識別子を持ち、ライフサイクルを通じて同一性が維持されるオブジェクト |
| 値オブジェクト（VO） | 識別子を持たず、属性の組み合わせで同一性が判定されるオブジェクト |
| Outbox | ドメインイベントを確実に発行するための中間テーブル。ドメインイベントの発行と業務トランザクションの原子性を保証する |
| 冪等性（Idempotency） | 同じ操作を複数回実行しても、結果が1回実行した場合と同じになる性質 |
| 補償トランザクション | 確定済みの処理を取り消すための逆操作。削除ではなく反対イベントとして表現する |

---

## 第4章 対象BC一覧

対象BCの詳細は未確定である。確定後は、ドメインスコープ定義書およびコンテキストマップで定義されたBC一覧を参照すること。

**注記：** 対象BC一覧は、コンテキストマップおよびドメインスコープ定義書の策定完了後に確定する。

**表6 — 対象BC一覧（テンプレート）**

| BC名 | 種別 | 概要 | 備考 |
|------|------|------|------|
| （確定後に記入） | Core/Supporting/Generic | （確定後に記入） | （確定後に記入） |

---

## 第5章 アーキテクチャ基本方針（DDD）

### 5.1 DDD採用の目的

本システムでは、複雑なビジネスドメインを適切にモデル化し、ソフトウェアの構造とビジネスの構造を一致させるため、DDD（ドメイン駆動設計）を採用する。

**表7 — DDD採用目的**

| 目的 | 説明 |
|------|------|
| ビジネスとコードの整合 | ユビキタス言語を通じて、ドメインエキスパートと開発者の共通理解を形成する |
| 複雑性の管理 | BCによる境界の明確化で、複雑なドメインを管理可能な単位に分割する |
| 変更容易性 | ドメインモデルの独立性により、ビジネス変更に追従しやすい構造を実現する |
| 自律性の確保 | BC単位での独立した開発・デプロイを可能にする |

### 5.2 戦略的設計の原則

#### 5.2.1 境界づけられたコンテキスト（Bounded Context）

**表8 — BC設計原則**

| 原則 | 説明 |
|------|------|
| BC単位のモデル | 各BCは独自のドメインモデルを持ち、他BCのモデルを直接参照してはならない |
| ユビキタス言語の範囲 | ユビキタス言語はBC内で一貫性を持ち、BC間では同じ用語が異なる意味を持つことを許容する |
| 自律性 | 各BCは独立してデプロイ・スケール可能な単位として設計しなければならない |
| データベース分離 | 各BCは独自のデータベーススキーマを持たなければならない。共有DBは原則禁止とする |

#### 5.2.2 コンテキスト間関係の基本パターン

BC間の関係は、コンテキストマップで定義されたパターンに従う。詳細は別ドキュメントで定義するが、基本パターンは以下の通り。

**表9 — コンテキスト間関係パターン**

| パターン | 説明 | 適用場面 |
|---------|------|----------|
| ACL（Anti-Corruption Layer） | 外部システムやレガシーシステムとの連携時に、翻訳層を設けて自BCのモデルを保護する | 外部会計システム（例）、銀行口座振替API（例）等との連携 |
| Shared Kernel | 複数BCで共有する小さなモデルを定義し、共同で管理する | 連絡先・住所BC（例）と共通マスターBC（例） |
| Customer/Supplier | 上流BC（Supplier）が下流BC（Customer）の要求に応じてAPIを提供する | BC間の依存関係がある場合 |
| Published Language | 標準化されたスキーマ・プロトコルでBC間を連携する | イベント駆動連携 |
| Conformist | 下流BCが上流BCのモデルをそのまま受け入れる | 変更不可能な外部システムとの連携 |

#### 5.2.3 BC間通信方式の選択基準

**表10 — BC間通信方式選択基準**

| 条件 | 推奨方式 | 理由 |
|------|---------|------|
| 即時応答が必要 | 同期API（REST） | ユーザー操作への即時フィードバック |
| 結果整合性で許容される | 非同期イベント | 疎結合性・耐障害性の向上 |
| 長時間トランザクション | Saga + 非同期イベント | タイムアウトリスクの回避 |
| 複数BCの協調が必要 | オーケストレーション型Saga | 複雑な業務フローの制御 |
| 単純な通知 | コレオグラフィ型イベント | シンプルな疎結合連携 |

### 5.3 戦術的設計の原則

#### 5.3.1 ドメインモデルの構成要素

**表11 — ドメインモデル構成要素**

| 要素 | 説明 | 設計上の注意点 |
|------|------|---------------|
| エンティティ（Entity） | 識別子を持ち、ライフサイクルを通じて同一性が維持されるオブジェクト | 識別子による同一性判定、状態変化を許容 |
| 値オブジェクト（Value Object） | 識別子を持たず、属性の組み合わせで同一性が判定されるオブジェクト | イミュータブル、等価性による比較、副作用なし |
| 集約（Aggregate） | 整合性境界を形成するエンティティ・VOの集まり | トランザクション整合性の単位、集約ルートを通じてのみアクセス |
| ドメインサービス | エンティティ・VOに属さないドメインロジック | ステートレス、ドメイン層に配置 |
| ドメインイベント | ドメイン内で発生した重要な出来事 | 過去形で命名、イミュータブル |
| リポジトリ | 集約の永続化・取得を担う抽象 | ドメイン層にインタフェース、インフラ層に実装 |
| ファクトリ | 複雑な集約の生成を担う | 生成ロジックのカプセル化 |

---

## 第6章 クリーンアーキテクチャ方針

### 6.1 クリーンアーキテクチャ採用の目的

本システムでは、フレームワーク・データベース・UIに依存しないドメインモデルを実現するため、クリーンアーキテクチャを採用する。

**表12 — クリーンアーキテクチャ採用目的**

| 目的 | 説明 |
|------|------|
| フレームワーク非依存 | ドメインロジックがSpring Framework等に依存せず、技術変更に強い構造を実現する |
| テスタビリティ | ドメインロジックを外部依存なしにテスト可能にする |
| UI非依存 | React UIの変更がドメインロジックに影響を与えない |
| DB非依存 | データベースの変更がドメインロジックに影響を与えない |
| 外部サービス非依存 | 外部サービスの変更がドメインロジックに影響を与えない |

### 6.2 同心円構造の定義

クリーンアーキテクチャの同心円構造を以下のように定義する。内側の層は外側の層に依存してはならない。

```
┌─────────────────────────────────────────────────────────────┐
│              Frameworks & Drivers (Layer 4)                 │
│  (Spring Boot, JPA, React, External Services)              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │          Interface Adapters (Layer 3)                │   │
│  │  (Controllers, Presenters, Gateways, Repositories)  │   │
│  │  ┌─────────────────────────────────────────────┐    │   │
│  │  │          Application (Layer 2)               │    │   │
│  │  │           (Use Cases)                       │    │   │
│  │  │  ┌─────────────────────────────────────┐   │    │   │
│  │  │  │         Domain (Layer 1)             │   │    │   │
│  │  │  │  (Entities, Value Objects,          │   │    │   │
│  │  │  │   Domain Services, Domain Events)   │   │    │   │
│  │  │  └─────────────────────────────────────┘   │    │   │
│  │  └─────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘

依存の方向: Layer 4 → Layer 3 → Layer 2 → Layer 1
```

### 6.3 各層の責務と配置要素

**表13 — 各層の責務と配置要素**

| 層 | 責務 | 配置要素 | 依存可能な層 | Spring/Java対応 |
|----|------|----------|------------|----------------|
| Layer 1: エンティティ層（Domain） | ビジネスルール・ドメインロジックの表現 | Entity, Value Object, Domain Service, Domain Event, Repository Interface, Factory Interface | なし（完全に独立） | POJOのみ、Spring注入禁止 |
| Layer 2: ユースケース層（Application） | ユースケースの実現、アプリケーション固有のビジネスルール | Use Case (Interactor), Input Port, Output Port, Application Service | Layer 1のみ | @Service可、@Transactional可 |
| Layer 3: アダプタ層（Interface Adapters） | 外部との入出力の変換 | Controller, Presenter, Gateway Implementation, Repository Implementation | Layer 1, 2 | @RestController, @Repository |
| Layer 4: 外部フレームワークとドライバー | フレームワーク・ドライバ・外部サービス | Web Framework, ORM, External API Client, Message Broker, UI Components | Layer 1, 2, 3 | Spring Boot設定, JPA Entity |

### 6.4 依存性ルール

#### 6.4.1 基本原則

**表14 — 依存性の基本原則**

| 原則 | 説明 |
|------|------|
| 依存の方向 | 依存は外側から内側への一方向のみ許可する。内側の層は外側の層を知ってはならない |
| 依存性逆転原則（DIP） | 外側の層の具象に依存する場合は、内側の層でインタフェースを定義し、外側の層で実装する |
| 境界を越えるデータ | 層の境界を越えるデータは、シンプルなDTO（Data Transfer Object）を使用する |
| フレームワーク独立性 | ドメイン層およびユースケース層は、Spring Frameworkに依存してはならない |

#### 6.4.2 依存関係の許可/禁止

**表15 — 依存関係の許可/禁止**

| 依存元 | 依存先 | 許可/禁止 | 備考 |
|--------|--------|----------|------|
| Controller | Use Case (Input Port) | 許可 | 適切な依存 |
| Use Case | Entity / Value Object | 許可 | 適切な依存 |
| Use Case | Repository Interface | 許可 | DIPにより実現 |
| Entity | Use Case | **禁止** | 依存の逆転 |
| Entity | Controller | **禁止** | 依存の逆転 |
| Entity | Framework（Spring等） | **禁止** | フレームワーク依存 |
| Domain層 | 外部API直接呼び出し | **禁止** | Gateway Interface経由のみ可 |
| Domain層 | DB直接アクセス | **禁止** | Repository Interface経由のみ可 |
| Domain Service | Entity / Value Object | 許可 | 適切な依存 |
| Domain Service | 外部I/O（HTTP, DB, ファイル等） | **禁止** | Interface経由のみ可 |
| Repository Implementation | Repository Interface | 許可 | DIPの実装側 |
| Repository Implementation | Entity | 許可 | エンティティの永続化 |

### 6.5 ポートとアダプタ

ヘキサゴナルアーキテクチャの概念を統合し、ポートとアダプタを明確に定義する。

**表16 — ポートとアダプタ**

| 要素 | 説明 | 配置層 | 例（Java/Spring） |
|------|------|--------|------------------|
| Input Port（駆動ポート） | ユースケースへの入力インタフェース | Application | `CreateOrderUseCase`（インタフェース） |
| Output Port（被駆動ポート） | ユースケースからの出力インタフェース | Application | `OrderRepository`（インタフェース）、`PaymentGateway`（インタフェース） |
| Primary Adapter（駆動アダプタ） | 外部からの入力を受け付けるアダプタ | Interface Adapters | `@RestController OrderController` |
| Secondary Adapter（被駆動アダプタ） | 外部への出力を行うアダプタ | Interface Adapters | `JpaOrderRepository`, `ExternalPaymentGatewayClient` |

### 6.6 整合境界規約

#### 6.6.1 同期整合性（ACID）の範囲

**表17 — 同期整合性境界**

| 原則 | 説明 |
|------|------|
| 1TX = 1集約 | 1トランザクションで変更できる集約は原則1つのみとしなければならない |
| BC越境TX禁止 | 異なるBC間で分散トランザクションを使用してはならない |
| Outbox同一TX | ドメインイベントのOutboxへの書き込みは、集約の更新と同一トランザクションで行わなければならない |
| 例外: Shared Kernel | Shared Kernelの場合に限り、同一TX内で複数集約の更新を許容する |

#### 6.6.2 結果整合性の範囲

**表18 — 結果整合性境界**

| 原則 | 説明 |
|------|------|
| BC間は結果整合性 | BC間のデータ整合性は、ドメインイベント経由の結果整合性で実現しなければならない |
| Sagaパターン | 複数BCにまたがる業務トランザクションは、Sagaパターンで実現しなければならない |
| 補償トランザクション | Saga失敗時は、補償トランザクションで整合性を回復しなければならない |

### 6.7 機微データ境界の原則

#### 6.7.1 機微データの定義

**表19 — 機微データ分類**

| 分類 | データ例 | 扱い |
|------|---------|------|
| 禁止データ | カード番号（PAN）、CVV、暗証番号 | システム内での保持・伝送を禁止。トークン化必須 |
| 要マスキング | 氏名、住所、電話番号、メールアドレス | ログ出力時はマスキング必須 |
| 要暗号化 | 口座番号、生年月日 | 保存時は暗号化必須 |
| 一般データ | 契約ID、取引ID、金額 | 通常の扱い |

#### 6.7.2 境界最小化原則

**表20 — 機微データ境界原則**

| 原則 | 説明 |
|------|------|
| 境界最小化 | 機微データを扱うコンポーネントは最小限に留めなければならない |
| イベント載せ禁止 | ドメインイベントに禁止データ・要マスキングデータを含めてはならない |
| API載せ禁止 | APIレスポンスに禁止データを含めてはならない |
| ログ出力禁止 | ログに禁止データ・要マスキングデータを平文で出力してはならない |
| 参照ID方式 | 機微データが必要な場合は、参照ID経由で必要な時点でのみ取得する |

---

## 第7章 ドメインモデル設計方針

### 7.1 集約設計の原則

集約は、トランザクション整合性を保証する境界として重要な役割を果たす。

**表21 — 集約設計原則**

| 原則 | 説明 |
|------|------|
| 整合性境界 | 集約はトランザクション整合性の境界を形成する。集約内の整合性はトランザクションで保証しなければならない |
| 集約ルート | 集約へのアクセスは必ず集約ルートを通じて行わなければならない。集約内部のエンティティへの直接アクセスを禁止する |
| 小さな集約 | 集約は可能な限り小さく設計し、パフォーマンスとスケーラビリティを確保すべきである |
| 集約間の参照 | 集約間の参照はIDによる間接参照としなければならない。オブジェクト参照を禁止する |
| 結果整合性 | 集約間の整合性は結果整合性（Eventual Consistency）で実現しなければならない |
| 不変条件の保護 | 集約は常に不変条件（Invariant）を満たす状態でなければならない |
| 単一トランザクション | 1トランザクションで1集約のみを変更しなければならない（Shared Kernel例外を除く） |

### 7.2 エンティティ設計の原則

**表22 — エンティティ設計原則**

| 原則 | 説明 |
|------|------|
| 識別子 | エンティティは一意な識別子を持ち、識別子で同一性を判定しなければならない |
| ライフサイクル | エンティティは生成・更新・削除のライフサイクルを持つ |
| 振る舞い | エンティティは自身の状態を変更する振る舞いを持ち、ドメインロジックをカプセル化しなければならない |
| 不変条件 | エンティティは常に不変条件（Invariant）を満たす状態でなければならない |
| セッター禁止 | 単純なセッターメソッドは提供せず、ビジネスの意図を表すメソッドを定義しなければならない |
| ドメインイベント発行 | 重要な状態変更時にはドメインイベントを発行しなければならない |

### 7.3 値オブジェクト設計の原則

**表23 — 値オブジェクト設計原則**

| 原則 | 説明 |
|------|------|
| イミュータブル | 値オブジェクトは生成後に状態を変更してはならない |
| 等価性 | 値オブジェクトは属性の組み合わせで等価性を判定しなければならない |
| 自己完結 | 値オブジェクトは自身の妥当性検証ロジックを持たなければならない |
| 副作用なし | 値オブジェクトのメソッドは副作用を持たず、新しい値オブジェクトを返さなければならない |
| ユビキタス言語 | 値オブジェクトはユビキタス言語の語彙を表現すべきである |
| プリミティブ回避 | プリミティブ型の多用を避け、意味のある値オブジェクトにすべきである |
| バリデーション | 生成時にバリデーションを実施し、不正な状態のVOが存在しないようにしなければならない |

### 7.4 ドメインサービス設計の原則

**表24 — ドメインサービス設計原則**

| 原則 | 説明 |
|------|------|
| ステートレス | ドメインサービスは状態を持ってはならない |
| エンティティ・VOに属さないロジック | 複数の集約にまたがる、または特定のエンティティ・VOに属さないドメインロジックを配置する |
| ドメイン層配置 | ドメインサービスはドメイン層に配置しなければならない（アプリケーションサービスとは異なる） |
| インタフェース定義 | 外部依存がある場合は、ドメイン層でインタフェースを定義しなければならない |
| 命名規則 | ドメインサービスの名前はユビキタス言語に基づき、ビジネスの意図を表現しなければならない |

### 7.5 ドメインイベント設計の原則

**表25 — ドメインイベント設計原則**

| 原則 | 説明 |
|------|------|
| 過去形命名 | ドメインイベントは過去形で命名しなければならない（例：OrderPlaced、PaymentCompleted） |
| イミュータブル | ドメインイベントは生成後に状態を変更してはならない |
| ビジネス視点 | 技術的な出来事ではなく、ビジネス上重要な出来事を表現しなければならない |
| タイムスタンプ | イベント発生日時を含めなければならない |
| コンテキスト情報 | イベントに関連する最小限のコンテキスト情報を含めるべきである |
| 機微データ禁止 | イベントに禁止データ・要マスキングデータを含めてはならない |

### 7.6 冪等性・重複・再送の原則

#### 7.6.1 冪等性設計の基本原則

**表26 — 冪等性設計原則**

| 原則 | 説明 |
|------|------|
| 冪等キー必須 | 更新系API・コマンドには冪等キー（Idempotency-Key）を必須としなければならない |
| 重複検出 | 冪等キーに基づく重複リクエストの検出機構を実装しなければならない |
| 再送前提 | 端末/ネットワーク都合のタイムアウト→再送を前提とした設計としなければならない |
| 冪等キー保存期間 | 冪等キーは最低24時間保存しなければならない（業務要件に応じて延長可） |

#### 7.6.2 重複リクエスト時の扱い

**表27 — 重複リクエスト時の扱い**

| パターン | 説明 | 適用場面 |
|---------|------|----------|
| 成功扱い | 重複リクエストを成功として処理し、初回と同じレスポンスを返す | 決済承認、契約申込 |
| 無視 | 重複リクエストを無視し、204 No Contentを返す | 通知、ログ出力 |
| 整合修復 | 重複検出時に整合性を確認し、必要に応じて修復する | 在庫更新、残高更新 |

### 7.7 取消・訂正イベントの原則

#### 7.7.1 基本原則

**表28 — 取消・訂正の基本原則**

| 原則 | 説明 |
|------|------|
| 削除禁止 | 「取り消し＝物理削除」としてはならない。すべての変更は追記として表現する |
| 反対イベント | 取消は「反対イベント」として表現しなければならない（例：PaymentCancelled） |
| 訂正イベント | 訂正は「訂正イベント」として表現しなければならない（例：AmountCorrected） |
| 監査証跡 | すべての取消・訂正は監査証跡として追跡可能でなければならない |

#### 7.7.2 確定後変更の標準パターン

**表29 — 確定後変更パターン**

| パターン | 説明 | 適用場面 |
|---------|------|----------|
| 補償トランザクション | 確定済み処理の逆操作を実行する | 決済取消、契約解約 |
| 再計上 | 元の処理を取消し、新しい内容で再計上する | 金額訂正、日付訂正 |
| 差分イベント | 変更差分のみをイベントとして発行する | 部分的な属性変更 |

### 7.8 順序逆転・遅延への対処原則

#### 7.8.1 順序保証の原則

**表30 — 順序保証原則**

| 原則 | 説明 |
|------|------|
| 順序非保証前提 | イベント駆動設計において、イベントの到着順序は保証されないことを前提としなければならない |
| 順序重要イベント | 順序が重要なイベント種別は明示的に定義し、パーティションキー等で順序を保証する |
| バージョン管理 | 集約にはバージョン番号を持たせ、古いバージョンへの更新を拒否する |

#### 7.8.2 順序非依存設計

**表31 — 順序非依存設計原則**

| 原則 | 説明 |
|------|------|
| 単調性 | 状態遷移は単調（後戻りしない）に設計すべきである |
| 因果関係の明示 | イベント間の因果関係がある場合は、causation-idで明示しなければならない |
| 遅延耐性 | イベントが遅延して到着しても破綻しない状態遷移を設計しなければならない |
| タイムスタンプ比較 | 更新時はイベントのタイムスタンプを比較し、古いイベントは無視する |

### 7.9 Outbox標準部品規約

#### 7.9.1 Outboxパターンの必須化

**表32 — Outbox規約**

| 原則 | 説明 |
|------|------|
| Outbox必須 | ドメインイベントの発行は、Outboxテーブル経由で行わなければならない |
| 同一TX | 集約の更新とOutboxへの書き込みは、同一トランザクションで行わなければならない |
| リレー処理 | Outboxテーブルのイベントは、専用のリレー処理（Polling Publisher等）で発行する |
| At-least-once | イベント発行はat-least-once（最低1回）を保証し、受信側で冪等性を担保する |

#### 7.9.2 Outboxテーブル構造

**表33 — Outboxテーブル標準構造**

| カラム | 型 | 説明 |
|--------|-----|------|
| id | UUID | イベントの一意識別子 |
| aggregate_type | VARCHAR | 集約の種別 |
| aggregate_id | VARCHAR | 集約のID |
| event_type | VARCHAR | イベントの種別 |
| payload | JSON | イベントのペイロード |
| created_at | TIMESTAMP | イベント作成日時 |
| published_at | TIMESTAMP | イベント発行日時（NULL＝未発行） |

---

## 第8章 CQRS方針

### 8.1 CQRS採用の目的

本システムでは、監査ログ・アプリケーションログ等の参照系処理において、コマンド（更新）とクエリ（参照）を分離するCQRS（Command Query Responsibility Segregation）パターンの適用を検討する。

**表34 — CQRS採用目的**

| 目的 | 説明 |
|------|------|
| 読み書きの最適化 | 更新系と参照系で異なるデータモデル・ストレージを使用し、それぞれを最適化する |
| スケーラビリティ | 参照系のスケールアウトを独立して行えるようにする |
| 複雑なクエリの実現 | 複雑な集計・検索要件を、正規化されたドメインモデルに影響を与えずに実現する |
| パフォーマンス | 参照系を非正規化されたビューで最適化し、応答性能を向上させる |
| 責務の分離 | 更新と参照の責務を明確に分離し、それぞれに最適な設計を適用する |

### 8.2 CQRS適用範囲

**表35 — CQRS適用範囲**

| 適用対象 | 適用理由 | 優先度 |
|---------|---------|--------|
| 監査ログ参照 | 監査ログの検索・集計・レポート出力の最適化 | 高 |
| アプリケーションログ参照 | アプリケーションログの検索・分析の最適化 | 高 |
| 過去データ参照 | 履歴データの検索・集計（必要に応じて検討） | 中 |
| ダッシュボード・レポート | 複雑な集計を要するレポートの最適化 | 中 |

上記以外の一般的なCRUD操作については、CQRSの適用は必須ではない。適用の要否はBC単位で判断してもよい。

### 8.3 CQRS設計方針

#### 8.3.1 コマンドモデル（更新系）

**表36 — コマンドモデル原則**

| 原則 | 説明 |
|------|------|
| ドメインモデル使用 | 更新系はドメインモデル（集約）を通じて処理しなければならない |
| 整合性担保 | トランザクション整合性を集約単位で担保しなければならない |
| イベント発行 | 状態変更時にドメインイベントを発行し、クエリモデルの更新をトリガーしなければならない |
| ビジネスルール実行 | すべてのビジネスルールはコマンドモデル側で実行しなければならない |

#### 8.3.2 クエリモデル（参照系）

**表37 — クエリモデル原則**

| 原則 | 説明 |
|------|------|
| 読み取り専用 | クエリモデルは読み取り専用とし、更新を行ってはならない |
| 非正規化 | 参照要件に最適化された非正規化構造を許容する |
| 結果整合性 | コマンドモデルとの整合性は結果整合性で実現してもよい |
| プロジェクション | ドメインイベントを購読し、クエリモデル（プロジェクション）を更新すべきである |
| 複数ビュー | 同一データに対して複数の最適化されたビューを持つことを許容する |

### 8.4 イベントソーシングの検討

監査証跡が重要なデータについては、イベントソーシングパターンの適用を検討する。ただし、全BCへの一律適用は行わず、要件に応じてBC単位で検討しなければならない。

**表38 — イベントソーシング検討観点**

| 検討観点 | 説明 |
|---------|------|
| 監査要件 | すべての状態変化を追跡する必要がある場合に検討する |
| 時間旅行クエリ | 過去の任意時点の状態を再現する必要がある場合に検討する |
| 複雑性 | イベントソーシングの複雑性とメリットを比較検討しなければならない |
| 既存資産 | 既存のデータモデル・運用との整合性を考慮しなければならない |
| パフォーマンス | イベント再生のパフォーマンスを考慮しなければならない |

---

## 第9章 SBE/Living Documentation方針

### 9.1 SBE採用の目的

本システムでは、仕様書の陳腐化を防止し、仕様とコードの整合性を継続的に保証するため、SBE（Specification by Example）に基づくLiving Documentationを採用する。

**表39 — SBE採用目的**

| 目的 | 説明 |
|------|------|
| 仕様の陳腐化防止 | 実行可能な仕様により、仕様書とコードの乖離を防止する |
| 共通理解の形成 | 具体例を用いた仕様定義により、ステークホルダー間の共通理解を形成する |
| 継続的な検証 | テスト実行により、仕様の正しさを継続的に検証する |
| ドキュメントの自動生成 | テスト結果からドキュメントを自動生成し、常に最新の状態を維持する |

### 9.2 仕様定義の二元管理

本システムでは、仕様を「振る舞い」と「構造」に分離して管理する。

**表40 — 仕様定義の二元管理**

| 区分 | 定義形式 | 管理単位 | 説明 |
|------|---------|---------|------|
| 振る舞い | Gherkin（.feature） | BC単位 | ユースケース・ビジネスルールの振る舞いを具体例で定義する |
| 構造 | 仕様書（Markdown等） | BC単位 | エンティティ・VO・集約の構造・属性を定義する |

### 9.3 Gherkinによる振る舞い定義

#### 9.3.1 Gherkin記述方針

**表41 — Gherkin記述原則**

| 原則 | 説明 |
|------|------|
| ユビキタス言語 | Gherkinのシナリオはユビキタス言語で記述しなければならない |
| ビジネス視点 | 技術的な実装詳細ではなく、ビジネスの視点でシナリオを記述しなければならない |
| 具体例 | 抽象的なルールではなく、具体的な例（値）を用いて記述しなければならない |
| 独立性 | 各シナリオは他のシナリオに依存せず、独立して実行可能でなければならない |
| Given-When-Then | Given（前提条件）、When（操作）、Then（期待結果）の形式で記述しなければならない |

#### 9.3.2 Gherkinファイルの管理

**表42 — Gherkinファイル管理方針**

| 項目 | 方針 |
|------|------|
| 配置場所 | BC単位のディレクトリに配置しなければならない |
| 命名規則 | フィーチャー名は対応するユースケース・ドメインルールと整合させなければならない |
| バージョン管理 | ソースコードと同一リポジトリで管理し、変更履歴を追跡可能にしなければならない |
| レビュー | Gherkinシナリオはドメインエキスパートと共にレビューしなければならない |

### 9.4 Living Documentationの原則

#### 9.4.1 基本原則

**表43 — Living Documentation基本原則**

| 原則 | 説明 |
|------|------|
| 実行可能な仕様 | Gherkinシナリオは自動テストとして実行可能でなければならない |
| テスト = 仕様検証 | テストの成功は、仕様が正しく実装されていることを保証する |
| 失敗 = 乖離検出 | テストの失敗は、仕様とコードの乖離を検出する手段である |
| 継続的実行 | CI/CDパイプラインでGherkinテストを継続的に実行しなければならない |
| ドキュメント生成 | テスト結果からHTMLレポート等のドキュメントを自動生成すべきである |

#### 9.4.2 仕様変更時のルール

**表44 — 仕様変更時ルール**

| ルール | 説明 |
|-------|------|
| Gherkin先行 | ビジネスルール変更時は、まずGherkinシナリオを更新しなければならない |
| テスト失敗の受容 | Gherkin更新後、対応するテストが失敗することを確認しなければならない |
| 実装による修正 | テストが通るように実装を修正する（TDDサイクル） |
| 仕様書同期 | 構造に影響がある場合は、構造仕様書も同時に更新しなければならない |

### 9.5 TDD連携

**表45 — TDDとの連携**

| 項目 | 方針 |
|------|------|
| ユニットテスト | エンティティ・VOのビジネスロジックはユニットテストで検証しなければならない |
| 統合テスト | ユースケース層の振る舞いは統合テストで検証しなければならない |
| Gherkinテスト | エンドツーエンドの振る舞いはGherkinテストで検証しなければならない |
| テストピラミッド | ユニットテスト > 統合テスト > E2Eテストのバランスを保つべきである |
| テストフレームワーク | JUnit 5 + Cucumber（Java）を標準テストフレームワークとする |

---

## 付録A 未確定事項一覧

本方針書において「未確定」と記載された事項を以下にまとめる。これらは後続の検討・合意形成により確定させなければならない。

**表A.1 — 未確定事項一覧**

| 章節 | 項目 | 備考 |
|------|------|------|
| 1.2 | 対象BC一覧 | コンテキストマップおよびドメインスコープ定義書の策定完了後に確定 |
| 1.2 | PoC/一時検証用コンポーネントの例外承認ルール | 詳細運用ルールの策定が必要 |
| 8.4 | イベントソーシングの適用BC | BC単位での適用可否判断が必要 |

---

## 付録B 検討が必要な論点

以下は、本方針書の運用にあたり検討が必要な論点である。

1. **BC間通信の実装方式**
   - 同期通信（REST API、gRPC）vs 非同期通信（メッセージング）の選択基準
   - イベント駆動アーキテクチャの適用範囲
   - Sagaパターンの実装方式

2. **データベース分離の程度**
   - BC単位での完全なDB分離 vs スキーマレベル分離 vs 論理的分離
   - Shared Kernelの実装方式（共有DB、レプリケーション、API経由）
   - マイクロサービス化の段階的アプローチ

3. **集約サイズの最適化**
   - パフォーマンス要件と整合性要件のバランス
   - 集約の分割/結合の判断基準
   - 結果整合性の許容範囲

4. **CQRS/イベントソーシングの導入範囲**
   - どのBCにCQRSを適用するか
   - イベントソーシングの適用可否
   - プロジェクション更新の信頼性確保

5. **開発生産性とアーキテクチャ原則のバランス**
   - ボイラープレートコードの削減
   - コード生成ツールの活用
   - アーキテクチャルールの自動検証

6. **既存システムからの移行戦略**
   - ストラングラーパターンの適用
   - ACLの実装範囲
   - データ移行アプローチ

7. **Gherkinテストの運用**
   - シナリオ数の管理（肥大化への対応）
   - 実行時間の最適化
   - ステップ定義の再利用戦略
   - ドメインエキスパートの関与プロセス

---

## 付録C ディレクトリ構造例（Java/Spring Boot）

以下は、クリーンアーキテクチャに基づくJava/Spring Bootプロジェクトの標準ディレクトリ構造である。

```
src/main/java/com/example/{bc-name}/
├── domain/                          # Layer 1: ドメイン層
│   ├── model/
│   │   ├── aggregate/               # 集約ルート
│   │   │   └── Order.java
│   │   ├── entity/                  # エンティティ
│   │   │   └── OrderItem.java
│   │   ├── valueobject/             # 値オブジェクト
│   │   │   ├── OrderId.java
│   │   │   ├── Money.java
│   │   │   └── Quantity.java
│   │   └── event/                   # ドメインイベント
│   │       ├── OrderPlaced.java
│   │       └── OrderCancelled.java
│   ├── service/                     # ドメインサービス
│   │   └── PricingService.java
│   └── repository/                  # リポジトリインタフェース
│       └── OrderRepository.java
│
├── application/                     # Layer 2: アプリケーション層
│   ├── usecase/                     # ユースケース
│   │   ├── PlaceOrderUseCase.java
│   │   └── CancelOrderUseCase.java
│   ├── port/
│   │   ├── input/                   # 入力ポート（ユースケースIF）
│   │   │   └── PlaceOrderInputPort.java
│   │   └── output/                  # 出力ポート
│   │       └── PaymentGateway.java
│   └── dto/                         # DTO
│       ├── PlaceOrderCommand.java
│       └── OrderResponse.java
│
├── adapter/                         # Layer 3: アダプタ層
│   ├── inbound/
│   │   └── web/                     # REST Controller
│   │       └── OrderController.java
│   └── outbound/
│       ├── persistence/             # リポジトリ実装
│       │   ├── JpaOrderRepository.java
│       │   ├── OrderJpaEntity.java
│       │   └── OutboxJpaEntity.java
│       └── gateway/                 # 外部ゲートウェイ実装
│           └── ExternalPaymentGateway.java
│
└── infrastructure/                  # Layer 4: インフラ層
    ├── config/                      # Spring設定
    │   └── JpaConfig.java
    └── messaging/                   # メッセージング
        └── OutboxRelayScheduler.java
```

---

## 付録D ドメインイベント例

ハウスクレジットシステムで想定されるドメインイベントの例を以下に示す。

**表D.1 — ドメインイベント例**

| BC | イベント名 | 説明 | ペイロード例 |
|----|-----------|------|-------------|
| 契約BC | ContractCreated | 契約が作成された | contractId, customerId, productType, createdAt |
| 契約BC | ContractActivated | 契約が有効化された | contractId, activatedAt |
| 契約BC | ContractTerminated | 契約が解約された | contractId, terminatedAt, reason |
| 決済BC | PaymentAuthorized | 決済が承認された | paymentId, contractId, amount, authorizedAt |
| 決済BC | PaymentCaptured | 決済が確定した | paymentId, capturedAt |
| 決済BC | PaymentCancelled | 決済が取り消された | paymentId, cancelledAt, reason |
| 請求BC | BillingCreated | 請求が作成された | billingId, contractId, amount, dueDate |
| 請求BC | BillingPaid | 請求が支払われた | billingId, paidAt, paidAmount |
| 請求BC | BillingOverdue | 請求が延滞した | billingId, overdueAt |

---

## 付録E Gherkin記述例

ハウスクレジットシステムにおけるGherkin記述例を以下に示す。

```gherkin
# language: ja
機能: 契約申込
  ハウスクレジットの契約を申し込むことができる

  背景:
    前提 顧客「田中太郎」が存在する
    かつ 商品「ショッピングローン」が存在する

  シナリオ: 正常な契約申込
    もし 顧客「田中太郎」が商品「ショッピングローン」で契約を申し込む
    かつ 利用限度額を「500000」円で設定する
    ならば 契約が「申込中」ステータスで作成される
    かつ 「ContractCreated」イベントが発行される

  シナリオ: 利用限度額超過
    もし 顧客「田中太郎」が商品「ショッピングローン」で契約を申し込む
    かつ 利用限度額を「10000000」円で設定する
    ならば エラー「利用限度額が上限を超えています」が返される
    かつ 契約は作成されない

  シナリオ: 重複申込の検出（冪等性）
    前提 冪等キー「REQ-001」で契約申込が既に完了している
    もし 同じ冪等キー「REQ-001」で契約申込を再送する
    ならば 元の契約情報が返される
    かつ 新しい契約は作成されない
```

```gherkin
# language: ja
機能: 決済取消
  確定済みの決済を取り消すことができる

  背景:
    前提 契約「C-001」に対する決済「P-001」が確定済みである

  シナリオ: 正常な決済取消
    もし 決済「P-001」を取り消す
    ならば 決済のステータスが「取消済」になる
    かつ 「PaymentCancelled」イベントが発行される
    かつ 元の決済レコードは削除されない

  シナリオ: 補償トランザクションの発行
    前提 決済「P-001」の取消により請求BCへの補償が必要である
    もし 決済「P-001」を取り消す
    ならば 請求BCに「BillingReversalRequested」イベントが送信される
```

---

## 付録F React フロントエンド構造例

以下は、Reactフロントエンドの標準ディレクトリ構造である。

```
src/
├── features/                        # 機能（BC）単位のディレクトリ
│   ├── contract/                    # 契約機能
│   │   ├── components/              # UI コンポーネント
│   │   │   ├── ContractForm.tsx
│   │   │   └── ContractList.tsx
│   │   ├── hooks/                   # カスタムフック
│   │   │   └── useContract.ts
│   │   ├── api/                     # API呼び出し
│   │   │   └── contractApi.ts
│   │   ├── types/                   # 型定義
│   │   │   └── contract.types.ts
│   │   └── pages/                   # ページコンポーネント
│   │       └── ContractPage.tsx
│   └── payment/                     # 決済機能
│       └── ...
│
├── shared/                          # 共通コンポーネント・ユーティリティ
│   ├── components/
│   │   ├── Button.tsx
│   │   └── Input.tsx
│   ├── hooks/
│   │   └── useApi.ts
│   └── utils/
│       └── formatters.ts
│
├── app/                             # アプリケーション設定
│   ├── App.tsx
│   ├── routes.tsx
│   └── store.ts
│
└── index.tsx                        # エントリーポイント
```

**表F.1 — フロントエンド設計原則**

| 原則 | 説明 |
|------|------|
| 機能単位の分割 | バックエンドのBC単位に対応した機能ディレクトリ構造とする |
| TypeScript必須 | すべてのコードはTypeScriptで記述しなければならない |
| 型安全なAPI呼び出し | OpenAPI定義から生成した型を使用しなければならない |
| 状態管理 | グローバル状態は最小限とし、サーバー状態はReact Query等で管理すべきである |
| コンポーネント設計 | Presentational/Containerパターンを適用すべきである |

---

## 改版履歴

| 版数 | 日付 | 変更内容 | 作成者 |
|------|------|---------|--------|
| 1.0 | 2026-01-14 | 初版作成 | - |
| 1.1 | 2026-01-15 | 技術スタック追加、機能ガードレール強化、付録追加 | - |
